/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.3.0 Tue Dec  5 18:06:15 2023.
 */

#ifndef CAN_C_H
#define CAN_C_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CAN_C_VCU_ERROR_FRAME_ID (0x102u)
#define CAN_C_VCU_STATE_FRAME_ID (0x101u)
#define CAN_C_VCU_SENSORS_FRAME_ID (0x100u)
#define CAN_C_PM100_MODULATION_AND_FLUX_INFO_FRAME_ID (0xadu)
#define CAN_C_PM100_TORQUE_AND_TIMER_INFO_FRAME_ID (0xacu)
#define CAN_C_PM100_READ_WRITE_PARAM_RESPONSE_FRAME_ID (0xc2u)
#define CAN_C_PM100_READ_WRITE_PARAM_COMMAND_FRAME_ID (0xc1u)
#define CAN_C_PM100_COMMAND_MESSAGE_FRAME_ID (0xc0u)
#define CAN_C_PM100_FAULT_CODES_FRAME_ID (0xabu)
#define CAN_C_PM100_INTERNAL_STATES_FRAME_ID (0xaau)
#define CAN_C_PM100_INTERNAL_VOLTAGES_FRAME_ID (0xa9u)
#define CAN_C_PM100_FLUX_ID_IQ_INFO_FRAME_ID (0xa8u)
#define CAN_C_PM100_VOLTAGE_INFO_FRAME_ID (0xa7u)
#define CAN_C_PM100_CURRENT_INFO_FRAME_ID (0xa6u)
#define CAN_C_PM100_MOTOR_POSITION_INFO_FRAME_ID (0xa5u)
#define CAN_C_PM100_DIGITAL_INPUT_STATUS_FRAME_ID (0xa4u)
#define CAN_C_PM100_ANALOG_INPUT_VOLTAGES_FRAME_ID (0xa3u)
#define CAN_C_PM100_TEMPERATURE_SET_3_FRAME_ID (0xa2u)
#define CAN_C_PM100_TEMPERATURE_SET_2_FRAME_ID (0xa1u)
#define CAN_C_PM100_TEMPERATURE_SET_1_FRAME_ID (0xa0u)
#define CAN_C_PM100_FIRMWARE_INFO_FRAME_ID (0xaeu)
#define CAN_C_PM100_DIAG_DATA_FRAME_ID (0xafu)
#define CAN_C_PM100_U2_C_COMMAND_TXD_FRAME_ID (0x1d7u)
#define CAN_C_PM100_U2_C_MESSAGE_RXD_FRAME_ID (0x1d5u)
#define CAN_C_BMS_CURRENT_LIMIT_FRAME_ID (0x202u)
#define CAN_C_PM100_FAST_INFO_FRAME_ID (0xb0u)

/* Frame lengths in bytes. */
#define CAN_C_VCU_ERROR_LENGTH (6u)
#define CAN_C_VCU_STATE_LENGTH (4u)
#define CAN_C_VCU_SENSORS_LENGTH (8u)
#define CAN_C_PM100_MODULATION_AND_FLUX_INFO_LENGTH (8u)
#define CAN_C_PM100_TORQUE_AND_TIMER_INFO_LENGTH (8u)
#define CAN_C_PM100_READ_WRITE_PARAM_RESPONSE_LENGTH (8u)
#define CAN_C_PM100_READ_WRITE_PARAM_COMMAND_LENGTH (8u)
#define CAN_C_PM100_COMMAND_MESSAGE_LENGTH (8u)
#define CAN_C_PM100_FAULT_CODES_LENGTH (8u)
#define CAN_C_PM100_INTERNAL_STATES_LENGTH (8u)
#define CAN_C_PM100_INTERNAL_VOLTAGES_LENGTH (8u)
#define CAN_C_PM100_FLUX_ID_IQ_INFO_LENGTH (8u)
#define CAN_C_PM100_VOLTAGE_INFO_LENGTH (8u)
#define CAN_C_PM100_CURRENT_INFO_LENGTH (8u)
#define CAN_C_PM100_MOTOR_POSITION_INFO_LENGTH (8u)
#define CAN_C_PM100_DIGITAL_INPUT_STATUS_LENGTH (8u)
#define CAN_C_PM100_ANALOG_INPUT_VOLTAGES_LENGTH (8u)
#define CAN_C_PM100_TEMPERATURE_SET_3_LENGTH (8u)
#define CAN_C_PM100_TEMPERATURE_SET_2_LENGTH (8u)
#define CAN_C_PM100_TEMPERATURE_SET_1_LENGTH (8u)
#define CAN_C_PM100_FIRMWARE_INFO_LENGTH (8u)
#define CAN_C_PM100_DIAG_DATA_LENGTH (8u)
#define CAN_C_PM100_U2_C_COMMAND_TXD_LENGTH (8u)
#define CAN_C_PM100_U2_C_MESSAGE_RXD_LENGTH (8u)
#define CAN_C_BMS_CURRENT_LIMIT_LENGTH (8u)
#define CAN_C_PM100_FAST_INFO_LENGTH (8u)

/* Extended or standard frame types. */
#define CAN_C_VCU_ERROR_IS_EXTENDED (0)
#define CAN_C_VCU_STATE_IS_EXTENDED (0)
#define CAN_C_VCU_SENSORS_IS_EXTENDED (0)
#define CAN_C_PM100_MODULATION_AND_FLUX_INFO_IS_EXTENDED (0)
#define CAN_C_PM100_TORQUE_AND_TIMER_INFO_IS_EXTENDED (0)
#define CAN_C_PM100_READ_WRITE_PARAM_RESPONSE_IS_EXTENDED (0)
#define CAN_C_PM100_READ_WRITE_PARAM_COMMAND_IS_EXTENDED (0)
#define CAN_C_PM100_COMMAND_MESSAGE_IS_EXTENDED (0)
#define CAN_C_PM100_FAULT_CODES_IS_EXTENDED (0)
#define CAN_C_PM100_INTERNAL_STATES_IS_EXTENDED (0)
#define CAN_C_PM100_INTERNAL_VOLTAGES_IS_EXTENDED (0)
#define CAN_C_PM100_FLUX_ID_IQ_INFO_IS_EXTENDED (0)
#define CAN_C_PM100_VOLTAGE_INFO_IS_EXTENDED (0)
#define CAN_C_PM100_CURRENT_INFO_IS_EXTENDED (0)
#define CAN_C_PM100_MOTOR_POSITION_INFO_IS_EXTENDED (0)
#define CAN_C_PM100_DIGITAL_INPUT_STATUS_IS_EXTENDED (0)
#define CAN_C_PM100_ANALOG_INPUT_VOLTAGES_IS_EXTENDED (0)
#define CAN_C_PM100_TEMPERATURE_SET_3_IS_EXTENDED (0)
#define CAN_C_PM100_TEMPERATURE_SET_2_IS_EXTENDED (0)
#define CAN_C_PM100_TEMPERATURE_SET_1_IS_EXTENDED (0)
#define CAN_C_PM100_FIRMWARE_INFO_IS_EXTENDED (0)
#define CAN_C_PM100_DIAG_DATA_IS_EXTENDED (0)
#define CAN_C_PM100_U2_C_COMMAND_TXD_IS_EXTENDED (0)
#define CAN_C_PM100_U2_C_MESSAGE_RXD_IS_EXTENDED (0)
#define CAN_C_BMS_CURRENT_LIMIT_IS_EXTENDED (0)
#define CAN_C_PM100_FAST_INFO_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */


/* Frame Names. */
#define CAN_C_VCU_ERROR_NAME "VCU_Error"
#define CAN_C_VCU_STATE_NAME "VCU_State"
#define CAN_C_VCU_SENSORS_NAME "VCU_Sensors"
#define CAN_C_PM100_MODULATION_AND_FLUX_INFO_NAME "PM100_Modulation_And_Flux_Info"
#define CAN_C_PM100_TORQUE_AND_TIMER_INFO_NAME "PM100_Torque_And_Timer_Info"
#define CAN_C_PM100_READ_WRITE_PARAM_RESPONSE_NAME "PM100_Read_Write_Param_Response"
#define CAN_C_PM100_READ_WRITE_PARAM_COMMAND_NAME "PM100_Read_Write_Param_Command"
#define CAN_C_PM100_COMMAND_MESSAGE_NAME "PM100_Command_Message"
#define CAN_C_PM100_FAULT_CODES_NAME "PM100_Fault_Codes"
#define CAN_C_PM100_INTERNAL_STATES_NAME "PM100_Internal_States"
#define CAN_C_PM100_INTERNAL_VOLTAGES_NAME "PM100_Internal_Voltages"
#define CAN_C_PM100_FLUX_ID_IQ_INFO_NAME "PM100_Flux_ID_IQ_Info"
#define CAN_C_PM100_VOLTAGE_INFO_NAME "PM100_Voltage_Info"
#define CAN_C_PM100_CURRENT_INFO_NAME "PM100_Current_Info"
#define CAN_C_PM100_MOTOR_POSITION_INFO_NAME "PM100_Motor_Position_Info"
#define CAN_C_PM100_DIGITAL_INPUT_STATUS_NAME "PM100_Digital_Input_Status"
#define CAN_C_PM100_ANALOG_INPUT_VOLTAGES_NAME "PM100_Analog_Input_Voltages"
#define CAN_C_PM100_TEMPERATURE_SET_3_NAME "PM100_Temperature_Set_3"
#define CAN_C_PM100_TEMPERATURE_SET_2_NAME "PM100_Temperature_Set_2"
#define CAN_C_PM100_TEMPERATURE_SET_1_NAME "PM100_Temperature_Set_1"
#define CAN_C_PM100_FIRMWARE_INFO_NAME "PM100_Firmware_Info"
#define CAN_C_PM100_DIAG_DATA_NAME "PM100_Diag_Data"
#define CAN_C_PM100_U2_C_COMMAND_TXD_NAME "PM100_U2C_Command_Txd"
#define CAN_C_PM100_U2_C_MESSAGE_RXD_NAME "PM100_U2C_Message_Rxd"
#define CAN_C_BMS_CURRENT_LIMIT_NAME "BMS_Current_Limit"
#define CAN_C_PM100_FAST_INFO_NAME "PM100_Fast_Info"

/* Signal Names. */
#define CAN_C_VCU_ERROR_VCU_CTRL_ERROR_NAME "VCU_CTRL_Error"
#define CAN_C_VCU_ERROR_VCU_SCS_ERROR_NAME "VCU_SCS_Error"
#define CAN_C_VCU_ERROR_VCU_PM100_ERROR_NAME "VCU_PM100_Error"
#define CAN_C_VCU_ERROR_VCU_RTCAN1_ERROR_NAME "VCU_RTCAN1_Error"
#define CAN_C_VCU_ERROR_VCU_RTCAN2_ERROR_NAME "VCU_RTCAN2_Error"
#define CAN_C_VCU_ERROR_VCU_CANBC_ERROR_NAME "VCU_CANBC_Error"
#define CAN_C_VCU_STATE_VCU_ROLLING_COUNTER_NAME "VCU_Rolling_Counter"
#define CAN_C_VCU_STATE_VCU_CTRL_STATE_NAME "VCU_CTRL_State"
#define CAN_C_VCU_STATE_VCU_R2_D_NAME "VCU_R2D"
#define CAN_C_VCU_STATE_VCU_DRS_ACTIVE_NAME "VCU_DRS_Active"
#define CAN_C_VCU_STATE_VCU_DRS_ALLOWED_NAME "VCU_DRS_Allowed"
#define CAN_C_VCU_SENSORS_VCU_APPS_NAME "VCU_APPS"
#define CAN_C_VCU_SENSORS_VCU_BPS_NAME "VCU_BPS"
#define CAN_C_VCU_SENSORS_VCU_SAGL_NAME "VCU_SAGL"
#define CAN_C_VCU_SENSORS_VCU_TORQUE_REQUEST_NAME "VCU_Torque_Request"
#define CAN_C_PM100_MODULATION_AND_FLUX_INFO_PM100_MODULATION_INDEX_NAME "PM100_Modulation_Index"
#define CAN_C_PM100_MODULATION_AND_FLUX_INFO_PM100_FLUX_WEAKENING_OUTPUT_NAME "PM100_Flux_Weakening_Output"
#define CAN_C_PM100_MODULATION_AND_FLUX_INFO_PM100_ID_COMMAND_NAME "PM100_Id_Command"
#define CAN_C_PM100_MODULATION_AND_FLUX_INFO_PM100_IQ_COMMAND_NAME "PM100_Iq_Command"
#define CAN_C_PM100_TORQUE_AND_TIMER_INFO_PM100_COMMANDED_TORQUE_NAME "PM100_Commanded_Torque"
#define CAN_C_PM100_TORQUE_AND_TIMER_INFO_PM100_TORQUE_FEEDBACK_NAME "PM100_Torque_Feedback"
#define CAN_C_PM100_TORQUE_AND_TIMER_INFO_PM100_POWER_ON_TIMER_NAME "PM100_Power_On_Timer"
#define CAN_C_PM100_READ_WRITE_PARAM_RESPONSE_PM100_PARAMETER_ADDRESS_RESPONSE_NAME "PM100_Parameter_Address_Response"
#define CAN_C_PM100_READ_WRITE_PARAM_RESPONSE_PM100_WRITE_SUCCESS_NAME "PM100_Write_Success"
#define CAN_C_PM100_READ_WRITE_PARAM_RESPONSE_PM100_DATA_RESPONSE_NAME "PM100_Data_Response"
#define CAN_C_PM100_READ_WRITE_PARAM_COMMAND_PM100_PARAMETER_ADDRESS_COMMAND_NAME "PM100_Parameter_Address_Command"
#define CAN_C_PM100_READ_WRITE_PARAM_COMMAND_PM100_READ_WRITE_COMMAND_NAME "PM100_Read_Write_Command"
#define CAN_C_PM100_READ_WRITE_PARAM_COMMAND_PM100_DATA_COMMAND_NAME "PM100_Data_Command"
#define CAN_C_PM100_COMMAND_MESSAGE_PM100_TORQUE_COMMAND_NAME "PM100_Torque_Command"
#define CAN_C_PM100_COMMAND_MESSAGE_PM100_SPEED_COMMAND_NAME "PM100_Speed_Command"
#define CAN_C_PM100_COMMAND_MESSAGE_PM100_DIRECTION_COMMAND_NAME "PM100_Direction_Command"
#define CAN_C_PM100_COMMAND_MESSAGE_PM100_INVERTER_ENABLE_NAME "PM100_Inverter_Enable"
#define CAN_C_PM100_COMMAND_MESSAGE_PM100_INVERTER_DISCHARGE_NAME "PM100_Inverter_Discharge"
#define CAN_C_PM100_COMMAND_MESSAGE_PM100_SPEED_MODE_ENABLE_NAME "PM100_Speed_Mode_Enable"
#define CAN_C_PM100_COMMAND_MESSAGE_PM100_ROLLING_COUNTER_NAME "PM100_RollingCounter"
#define CAN_C_PM100_COMMAND_MESSAGE_PM100_TORQUE_LIMIT_COMMAND_NAME "PM100_Torque_Limit_Command"
#define CAN_C_PM100_FAULT_CODES_PM100_POST_FAULT_LO_NAME "PM100_Post_Fault_Lo"
#define CAN_C_PM100_FAULT_CODES_PM100_POST_FAULT_HI_NAME "PM100_Post_Fault_Hi"
#define CAN_C_PM100_FAULT_CODES_PM100_RUN_FAULT_LO_NAME "PM100_Run_Fault_Lo"
#define CAN_C_PM100_FAULT_CODES_PM100_RUN_FAULT_HI_NAME "PM100_Run_Fault_Hi"
#define CAN_C_PM100_INTERNAL_STATES_PM100_VSM_STATE_NAME "PM100_VSM_State"
#define CAN_C_PM100_INTERNAL_STATES_PM100_PWM_FREQUENCY_NAME "PM100_PWM_Frequency"
#define CAN_C_PM100_INTERNAL_STATES_PM100_INVERTER_STATE_NAME "PM100_Inverter_State"
#define CAN_C_PM100_INTERNAL_STATES_PM100_RELAY_1_STATUS_NAME "PM100_Relay_1_Status"
#define CAN_C_PM100_INTERNAL_STATES_PM100_RELAY_2_STATUS_NAME "PM100_Relay_2_Status"
#define CAN_C_PM100_INTERNAL_STATES_PM100_RELAY_3_STATUS_NAME "PM100_Relay_3_Status"
#define CAN_C_PM100_INTERNAL_STATES_PM100_RELAY_4_STATUS_NAME "PM100_Relay_4_Status"
#define CAN_C_PM100_INTERNAL_STATES_PM100_RELAY_5_STATUS_NAME "PM100_Relay_5_Status"
#define CAN_C_PM100_INTERNAL_STATES_PM100_RELAY_6_STATUS_NAME "PM100_Relay_6_Status"
#define CAN_C_PM100_INTERNAL_STATES_PM100_INVERTER_RUN_MODE_NAME "PM100_Inverter_Run_Mode"
#define CAN_C_PM100_INTERNAL_STATES_PM100_INVERTER_DISCHARGE_STATE_NAME "PM100_Inverter_Discharge_State"
#define CAN_C_PM100_INTERNAL_STATES_PM100_INVERTER_COMMAND_MODE_NAME "PM100_Inverter_Command_Mode"
#define CAN_C_PM100_INTERNAL_STATES_PM100_ROLLING_COUNTER_NAME "PM100_Rolling_Counter"
#define CAN_C_PM100_INTERNAL_STATES_PM100_INVERTER_ENABLE_STATE_NAME "PM100_Inverter_Enable_State"
#define CAN_C_PM100_INTERNAL_STATES_PM100_START_MODE_ACTIVE_NAME "PM100_Start_Mode_Active"
#define CAN_C_PM100_INTERNAL_STATES_PM100_INVERTER_ENABLE_LOCKOUT_NAME "PM100_Inverter_Enable_Lockout"
#define CAN_C_PM100_INTERNAL_STATES_PM100_DIRECTION_COMMAND_STATE_NAME "PM100_Direction_Command_State"
#define CAN_C_PM100_INTERNAL_STATES_PM100_BMS_ACTIVE_NAME "PM100_BMS_Active"
#define CAN_C_PM100_INTERNAL_STATES_PM100_BMS_TORQUE_LIMITING_NAME "PM100_BMS_Torque_Limiting"
#define CAN_C_PM100_INTERNAL_STATES_PM100_MAX_SPEED_LIMITING_NAME "PM100_Max_Speed_Limiting"
#define CAN_C_PM100_INTERNAL_STATES_PM100_LOW_SPEED_LIMITING_NAME "PM100_Low_Speed_Limiting"
#define CAN_C_PM100_INTERNAL_VOLTAGES_PM100_REFERENCE_VOLTAGE_1_5_NAME "PM100_Reference_Voltage_1_5"
#define CAN_C_PM100_INTERNAL_VOLTAGES_PM100_REFERENCE_VOLTAGE_2_5_NAME "PM100_Reference_Voltage_2_5"
#define CAN_C_PM100_INTERNAL_VOLTAGES_PM100_REFERENCE_VOLTAGE_5_0_NAME "PM100_Reference_Voltage_5_0"
#define CAN_C_PM100_INTERNAL_VOLTAGES_PM100_REFERENCE_VOLTAGE_12_0_NAME "PM100_Reference_Voltage_12_0"
#define CAN_C_PM100_FLUX_ID_IQ_INFO_PM100_FLUX_COMMAND_NAME "PM100_Flux_Command"
#define CAN_C_PM100_FLUX_ID_IQ_INFO_PM100_FLUX_FEEDBACK_NAME "PM100_Flux_Feedback"
#define CAN_C_PM100_FLUX_ID_IQ_INFO_PM100_ID_NAME "PM100_Id"
#define CAN_C_PM100_FLUX_ID_IQ_INFO_PM100_IQ_NAME "PM100_Iq"
#define CAN_C_PM100_VOLTAGE_INFO_PM100_DC_BUS_VOLTAGE_NAME "PM100_DC_Bus_Voltage"
#define CAN_C_PM100_VOLTAGE_INFO_PM100_OUTPUT_VOLTAGE_NAME "PM100_Output_Voltage"
#define CAN_C_PM100_VOLTAGE_INFO_PM100_VAB_VD_VOLTAGE_NAME "PM100_VAB_Vd_Voltage"
#define CAN_C_PM100_VOLTAGE_INFO_PM100_VBC_VQ_VOLTAGE_NAME "PM100_VBC_Vq_Voltage"
#define CAN_C_PM100_CURRENT_INFO_PM100_PHASE_A_CURRENT_NAME "PM100_Phase_A_Current"
#define CAN_C_PM100_CURRENT_INFO_PM100_PHASE_B_CURRENT_NAME "PM100_Phase_B_Current"
#define CAN_C_PM100_CURRENT_INFO_PM100_PHASE_C_CURRENT_NAME "PM100_Phase_C_Current"
#define CAN_C_PM100_CURRENT_INFO_PM100_DC_BUS_CURRENT_NAME "PM100_DC_Bus_Current"
#define CAN_C_PM100_MOTOR_POSITION_INFO_PM100_MOTOR_ANGLE_ELECTRICAL_NAME "PM100_Motor_Angle_Electrical"
#define CAN_C_PM100_MOTOR_POSITION_INFO_PM100_MOTOR_SPEED_NAME "PM100_Motor_Speed"
#define CAN_C_PM100_MOTOR_POSITION_INFO_PM100_ELECTRICAL_OUTPUT_FREQ_NAME "PM100_Electrical_Output_Freq"
#define CAN_C_PM100_MOTOR_POSITION_INFO_PM100_DELTA_RESOLVER_FILTERED_NAME "PM100_Delta_Resolver_Filtered"
#define CAN_C_PM100_DIGITAL_INPUT_STATUS_PM100_DIGITAL_INPUT_1_NAME "PM100_Digital_Input_1"
#define CAN_C_PM100_DIGITAL_INPUT_STATUS_PM100_DIGITAL_INPUT_2_NAME "PM100_Digital_Input_2"
#define CAN_C_PM100_DIGITAL_INPUT_STATUS_PM100_DIGITAL_INPUT_3_NAME "PM100_Digital_Input_3"
#define CAN_C_PM100_DIGITAL_INPUT_STATUS_PM100_DIGITAL_INPUT_4_NAME "PM100_Digital_Input_4"
#define CAN_C_PM100_DIGITAL_INPUT_STATUS_PM100_DIGITAL_INPUT_5_NAME "PM100_Digital_Input_5"
#define CAN_C_PM100_DIGITAL_INPUT_STATUS_PM100_DIGITAL_INPUT_6_NAME "PM100_Digital_Input_6"
#define CAN_C_PM100_DIGITAL_INPUT_STATUS_PM100_DIGITAL_INPUT_7_NAME "PM100_Digital_Input_7"
#define CAN_C_PM100_DIGITAL_INPUT_STATUS_PM100_DIGITAL_INPUT_8_NAME "PM100_Digital_Input_8"
#define CAN_C_PM100_ANALOG_INPUT_VOLTAGES_PM100_ANALOG_INPUT_1_NAME "PM100_Analog_Input_1"
#define CAN_C_PM100_ANALOG_INPUT_VOLTAGES_PM100_ANALOG_INPUT_2_NAME "PM100_Analog_Input_2"
#define CAN_C_PM100_ANALOG_INPUT_VOLTAGES_PM100_ANALOG_INPUT_3_NAME "PM100_Analog_Input_3"
#define CAN_C_PM100_ANALOG_INPUT_VOLTAGES_PM100_ANALOG_INPUT_4_NAME "PM100_Analog_Input_4"
#define CAN_C_PM100_ANALOG_INPUT_VOLTAGES_PM100_ANALOG_INPUT_5_NAME "PM100_Analog_Input_5"
#define CAN_C_PM100_ANALOG_INPUT_VOLTAGES_PM100_ANALOG_INPUT_6_NAME "PM100_Analog_Input_6"
#define CAN_C_PM100_TEMPERATURE_SET_3_PM100_RTD4_TEMPERATURE_NAME "PM100_RTD4_Temperature"
#define CAN_C_PM100_TEMPERATURE_SET_3_PM100_RTD5_TEMPERATURE_NAME "PM100_RTD5_Temperature"
#define CAN_C_PM100_TEMPERATURE_SET_3_PM100_MOTOR_TEMPERATURE_NAME "PM100_Motor_Temperature"
#define CAN_C_PM100_TEMPERATURE_SET_3_PM100_TORQUE_SHUDDER_NAME "PM100_Torque_Shudder"
#define CAN_C_PM100_TEMPERATURE_SET_2_PM100_CONTROL_BOARD_TEMPERATURE_NAME "PM100_Control_Board_Temperature"
#define CAN_C_PM100_TEMPERATURE_SET_2_PM100_RTD1_TEMPERATURE_NAME "PM100_RTD1_Temperature"
#define CAN_C_PM100_TEMPERATURE_SET_2_PM100_RTD2_TEMPERATURE_NAME "PM100_RTD2_Temperature"
#define CAN_C_PM100_TEMPERATURE_SET_2_PM100_RTD3_TEMPERATURE_NAME "PM100_RTD3_Temperature"
#define CAN_C_PM100_TEMPERATURE_SET_1_PM100_MODULE_A_NAME "PM100_Module_A"
#define CAN_C_PM100_TEMPERATURE_SET_1_PM100_MODULE_B_NAME "PM100_Module_B"
#define CAN_C_PM100_TEMPERATURE_SET_1_PM100_MODULE_C_NAME "PM100_Module_C"
#define CAN_C_PM100_TEMPERATURE_SET_1_PM100_GATE_DRIVER_BOARD_NAME "PM100_Gate_Driver_Board"
#define CAN_C_PM100_FIRMWARE_INFO_PM100_PROJECT_CODE_EEP_VER_NAME "PM100_Project_Code_EEP_Ver"
#define CAN_C_PM100_FIRMWARE_INFO_PM100_SW_VERSION_NAME "PM100_SW_Version"
#define CAN_C_PM100_FIRMWARE_INFO_PM100_DATE_CODE_MMDD_NAME "PM100_DateCode_MMDD"
#define CAN_C_PM100_FIRMWARE_INFO_PM100_DATE_CODE_YYYY_NAME "PM100_DateCode_YYYY"
#define CAN_C_PM100_DIAG_DATA_PM100_BUFFER_RECORD_NAME "PM100_Buffer_Record"
#define CAN_C_PM100_DIAG_DATA_PM100_BUFFER_SEGMENT_NAME "PM100_Buffer_Segment"
#define CAN_C_PM100_DIAG_DATA_PM100_DIAG_DATA_1_NAME "PM100_Diag_Data_1"
#define CAN_C_PM100_DIAG_DATA_PM100_DIAG_DATA_2_NAME "PM100_Diag_Data_2"
#define CAN_C_PM100_DIAG_DATA_PM100_DIAG_DATA_3_NAME "PM100_Diag_Data_3"
#define CAN_C_PM100_U2_C_COMMAND_TXD_PM100_ID_BYTE_NAME "PM100_ID_Byte"
#define CAN_C_PM100_U2_C_COMMAND_TXD_PM100_SETPOINT_CALC_NAME "PM100_Setpoint_Calc"
#define CAN_C_PM100_U2_C_MESSAGE_RXD_PM100_HV_INPUT_CURRENT_VALIDITY_NAME "PM100_HV_Input_Current_Validity"
#define CAN_C_PM100_U2_C_MESSAGE_RXD_PM100_14_V_MASTER_FAULT_NAME "PM100_14V_Master_Fault"
#define CAN_C_PM100_U2_C_MESSAGE_RXD_PM100_HV_INPUT_CURRENT_NAME "PM100_HV_Input_Current"
#define CAN_C_PM100_U2_C_MESSAGE_RXD_PM100_DTC_STATUS_NAME "PM100_DTC_Status"
#define CAN_C_PM100_U2_C_MESSAGE_RXD_PM100_DTC_INDEX_NAME "PM100_DTC_Index"
#define CAN_C_PM100_U2_C_MESSAGE_RXD_PM100_14_V_MONITOR_NAME "PM100_14V_Monitor"
#define CAN_C_PM100_U2_C_MESSAGE_RXD_PM100_14_V_CONDITIONAL_NAME "PM100_14V_Conditional"
#define CAN_C_PM100_U2_C_MESSAGE_RXD_PM100_14_V_CURRENT_MONITOR_NAME "PM100_14V_Current_Monitor"
#define CAN_C_BMS_CURRENT_LIMIT_PM100_MAX_DISCHARGE_CURRENT_NAME "PM100_Max_Discharge_Current"
#define CAN_C_BMS_CURRENT_LIMIT_PM100_MAX_CHARGE_CURRENT_NAME "PM100_Max_Charge_Current"
#define CAN_C_PM100_FAST_INFO_PM100_FAST_TORQUE_COMMAND_NAME "PM100_Fast_Torque_Command"
#define CAN_C_PM100_FAST_INFO_PM100_FAST_TORQUE_FEEDBACK_NAME "PM100_Fast_Torque_Feedback"
#define CAN_C_PM100_FAST_INFO_PM100_FAST_MOTOR_SPEED_NAME "PM100_Fast_Motor_Speed"
#define CAN_C_PM100_FAST_INFO_PM100_FAST_DC_BUS_VOLTAGE_NAME "PM100_Fast_DC_Bus_Voltage"

/**
 * Signals in message VCU_Error.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_vcu_error_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_ctrl_error;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_scs_error;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_pm100_error;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_rtcan1_error;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_rtcan2_error;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_canbc_error;
};

/**
 * Signals in message VCU_State.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_vcu_state_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t vcu_rolling_counter;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_ctrl_state;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_r2_d;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_drs_active;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vcu_drs_allowed;
};

/**
 * Signals in message VCU_Sensors.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_vcu_sensors_t {
    /**
     * Range: 0..1000 (0..100 %)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t vcu_apps;

    /**
     * Range: 0..1000 (0..100 -)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t vcu_bps;

    /**
     * Range: 0..1000 (0..100 deg)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t vcu_sagl;

    /**
     * Range: 0..65535 (0..6553.5 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t vcu_torque_request;
};

/**
 * Signals in message PM100_Modulation_And_Flux_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_modulation_and_flux_info_t {
    /**
     * This is the modulation index. The scale factor is x100. To get the actual modulation index divide the value by 100.
     *
     * Range: -32768..32767 (-3.2768..3.2767 -)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t pm100_modulation_index;

    /**
     * This is the current output of the flux regulator.
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_flux_weakening_output;

    /**
     * The commanded D-axis current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_id_command;

    /**
     * The commanded Q-axis current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_iq_command;
};

/**
 * Signals in message PM100_Torque_And_Timer_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_torque_and_timer_info_t {
    /**
     * The commanded Torque
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_commanded_torque;

    /**
     * Estimated motor torque feedback
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_torque_feedback;

    /**
     * Updated every 3 msec. This will roll over in approximately 150 days!
     *
     * Range: 0..4294933333 (0..12884800 Sec)
     * Scale: 0.003
     * Offset: 0
     */
    uint32_t pm100_power_on_timer;
};

/**
 * Signals in message PM100_Read_Write_Param_Response.
 *
 * The inverter response to each Parameter message that is received.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_read_write_param_response_t {
    /**
     * Valid EEPROM Parameter CAN addresses are between 100 and 499.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pm100_parameter_address_response;

    /**
     * 0=Write failure, 1=Success
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_write_success;

    /**
     * All EEPROM data is 16 bits and is contained in bytes 4 and 5. Bytes 6 and 7 should be ignored.
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pm100_data_response;
};

/**
 * Signals in message PM100_Read_Write_Param_Command.
 *
 * Parameter Message sent as needed by VCU to request info, change EEPROM, or command a function.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_read_write_param_command_t {
    /**
     * Valid EEPROM Parameter CAN addresses are between 100 and 499.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pm100_parameter_address_command;

    /**
     * 0=Read, 1=Write
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_read_write_command;

    /**
     * All EEPROM data is 16 bits and is contained in bytes 4 and 5.
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pm100_data_command;
};

/**
 * Signals in message PM100_Command_Message.
 *
 * The command message is used to transmit data to the controller. This message is sent from a user supplied external controller to the PMxxx controller.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_command_message_t {
    /**
     * Torque command when in torque mode
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_torque_command;

    /**
     * Speed commandused when in speed mode
     *
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t pm100_speed_command;

    /**
     * 0=CW, 1=CCW as veiwed from the shaft end of the motor
     *
     * Range: 0..1 (0..1 Bit)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_direction_command;

    /**
     * 0=Inverter OFF, 1 = Inverter ON
     *
     * Range: 0..1 (0..1 Bit)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_inverter_enable;

    /**
     * 0=Discharge Disable,
     * =Discharge Enable
     *
     * Range: 0..1 (0..1 Bit)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_inverter_discharge;

    /**
     * 0 = No change to mode, 1 = change to speed mode from torque mode
     *
     * Range: 0..1 (0..1 Bit)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_speed_mode_enable;

    /**
     * Rolling Counter command
     *
     * Range: 0..15 (0..15 Bits)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_rolling_counter;

    /**
     * Torque Limit, set to 0 to keep default
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_torque_limit_command;
};

/**
 * Signals in message PM100_Fault_Codes.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_fault_codes_t {
    /**
     * Each bit represents a fault. Please refer to PM100 Users Manual for details.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pm100_post_fault_lo;

    /**
     * Each bit represents a fault. Please refer to PM100 Users Manual for details.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pm100_post_fault_hi;

    /**
     * Each bit represents a fault. Please refer to PM100 Users Manual for details.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pm100_run_fault_lo;

    /**
     * Each bit represents a fault. Please refer to PM100 Users Manual for details.
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pm100_run_fault_hi;
};

/**
 * Signals in message PM100_Internal_States.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_internal_states_t {
    /**
     * Different states for the vehicle state machine
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_vsm_state;

    /**
     * The inverter PWM frequency
     *
     * Range: 0..255 (0..255 kHz)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_pwm_frequency;

    /**
     * Different states for the inverter state machine
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_inverter_state;

    /**
     * 0=OFF, 1=ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_relay_1_status;

    /**
     * 0=OFF, 1=ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_relay_2_status;

    /**
     * 0=OFF, 1=ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_relay_3_status;

    /**
     * 0=OFF, 1=ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_relay_4_status;

    /**
     * 0=OFF, 1=ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_relay_5_status;

    /**
     * 0=OFF, 1=ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_relay_6_status;

    /**
     * 0=Torque Mode, 1=Speed Mode
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_inverter_run_mode;

    /**
     * 0 = Disabled, 1 = Enabled, 2 = Speed Check, 3 = Active, 4 = Complete
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_inverter_discharge_state;

    /**
     * 0=CAN mode, 1=VSM mode
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_inverter_command_mode;

    /**
     * The current rolling counter value.
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_rolling_counter;

    /**
     * 0=Inverter Disabled,
     * 1=Inverter Enabled
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_inverter_enable_state;

    /**
     * If in Key Switch Mode 1 then indicates status of Start input being applied.  0 = not active, 1 = active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_start_mode_active;

    /**
     * 0=Lockout Disabled, 1=Lockout Enabled
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_inverter_enable_lockout;

    /**
     * 1 = Forward
     * 0 = 'Reverse' if inverter enabled  & 'Stopped' if inverter is disabled
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_direction_command_state;

    /**
     * 0 = BMS Not Active, 1 = BMS Active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_bms_active;

    /**
     * 0 = Not Limiting, 1 = Limiting
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_bms_torque_limiting;

    /**
     * 0 = Not Limiting, 1 = torque limiting due to maximum speed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_max_speed_limiting;

    /**
     * 0 = Not Limiting, 1 = Current limiting due to low motor speed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_low_speed_limiting;
};

/**
 * Signals in message PM100_Internal_Voltages.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_internal_voltages_t {
    /**
     * Internal reference voltage
     *
     * Range: -32768..32767 (-327.68..327.67 V)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pm100_reference_voltage_1_5;

    /**
     * Internal reference voltage
     *
     * Range: -32768..32767 (-327.68..327.67 V)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pm100_reference_voltage_2_5;

    /**
     * Transducer voltage
     *
     * Range: -32768..32767 (-327.68..327.67 V)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pm100_reference_voltage_5_0;

    /**
     * 12V Input Voltage
     *
     * Range: -32768..32767 (-327.68..327.67 V)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pm100_reference_voltage_12_0;
};

/**
 * Signals in message PM100_Flux_ID_IQ_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_flux_id_iq_info_t {
    /**
     * The commanded flux
     *
     * Range: -32768..32767 (-32.768..32.767 Wb)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t pm100_flux_command;

    /**
     * The estimated flux
     *
     * Range: -32768..32767 (-32.768..32.767 Wb)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t pm100_flux_feedback;

    /**
     * The measured Id current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_id;

    /**
     * The measured Iq current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_iq;
};

/**
 * Signals in message PM100_Voltage_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_voltage_info_t {
    /**
     * The actual measured value of the DC bus voltage
     *
     * Range: -32768..32767 (-3276.8..3276.7 V)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_dc_bus_voltage;

    /**
     * The calculated value of the output voltage, in peak line-neutral volts
     *
     * Range: -32768..32767 (-3276.8..3276.7 V)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_output_voltage;

    /**
     * Measured value of the voltage betwen phase A and Phase B
     *
     * Range: -32768..32767 (-3276.8..3276.7 V)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_vab_vd_voltage;

    /**
     * Measured value of the voltage between Phase B and Phase C
     *
     * Range: -32768..32767 (-3276.8..3276.7 V)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_vbc_vq_voltage;
};

/**
 * Signals in message PM100_Current_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_current_info_t {
    /**
     * The measured value of Phase A current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_phase_a_current;

    /**
     * The measured value of Phase B current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_phase_b_current;

    /**
     * The measured value of Phase C current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_phase_c_current;

    /**
     * The Calculated DC Bus Current
     *
     * Range: -32768..32767 (-3276.8..3276.7 A)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_dc_bus_current;
};

/**
 * Signals in message PM100_Motor_Position_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_motor_position_info_t {
    /**
     * The Electrical Angle of the motor as read by the encoder or resolver
     *
     * Range: 0..65535 (0..6553.5 deg)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t pm100_motor_angle_electrical;

    /**
     * The measured speed of the motor
     *
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t pm100_motor_speed;

    /**
     * The actual electrical frequency of the inverter
     *
     * Range: -32768..32767 (-3276.8..3276.7 hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_electrical_output_freq;

    /**
     * Used in calibration of resolver angle adjustment.
     *
     * Range: -32768..32767 (-3276.8..3276.7 deg)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_delta_resolver_filtered;
};

/**
 * Signals in message PM100_Digital_Input_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_digital_input_status_t {
    /**
     * Status of Digital Input #1
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_digital_input_1;

    /**
     * Status of Digital Input #2
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_digital_input_2;

    /**
     * Status of Digital Input #3
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_digital_input_3;

    /**
     * Status of Digital Input #4
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_digital_input_4;

    /**
     * Status of Digital Input #5
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_digital_input_5;

    /**
     * Status of Digital Input #6
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_digital_input_6;

    /**
     * Status of Digital Input #7
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_digital_input_7;

    /**
     * Status of Digital Input #8
     *
     * Range: 0..1 (0..1 boolean)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_digital_input_8;
};

/**
 * Signals in message PM100_Analog_Input_Voltages.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_analog_input_voltages_t {
    /**
     * Voltage on Analog Input #1
     *
     * Range: 0..1023 (0..10.23 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pm100_analog_input_1;

    /**
     * Voltage on Analog Input #2
     *
     * Range: 0..1023 (0..10.23 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pm100_analog_input_2;

    /**
     * Voltage on Analog Input #3
     *
     * Range: 0..1023 (0..10.23 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pm100_analog_input_3;

    /**
     * Voltage on Analog Input #4
     *
     * Range: 0..1023 (0..10.23 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pm100_analog_input_4;

    /**
     * Voltage on Analog Input #5
     *
     * Range: 0..1023 (0..10.23 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pm100_analog_input_5;

    /**
     * Voltage on Analog Input #6
     *
     * Range: 0..1023 (0..10.23 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pm100_analog_input_6;
};

/**
 * Signals in message PM100_Temperature_Set_3.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_temperature_set_3_t {
    /**
     * RTD 4 (PT1000) Temperature (Gen 2 only)
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_rtd4_temperature;

    /**
     * RTD 5 (PT1000) Temperature (Gen 2 only)
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_rtd5_temperature;

    /**
     * Motor Temperature Sensor
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_motor_temperature;

    /**
     * Shudder compensation value of torque
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_torque_shudder;
};

/**
 * Signals in message PM100_Temperature_Set_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_temperature_set_2_t {
    /**
     * Control Board Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_control_board_temperature;

    /**
     * RTD input 1 (PT1000) Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_rtd1_temperature;

    /**
     * RTD input 2 (PT1000) Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_rtd2_temperature;

    /**
     * RTD input 3 (PT1000) Temperature (Gen 2 only)
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_rtd3_temperature;
};

/**
 * Signals in message PM100_Temperature_Set_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_temperature_set_1_t {
    /**
     * IGBT Module A Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_module_a;

    /**
     * IGBT Module B Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_module_b;

    /**
     * IGBT Module C Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_module_c;

    /**
     * Gate Driver Board Temperature
     *
     * Range: -32768..32767 (-3276.8..3276.7 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_gate_driver_board;
};

/**
 * Signals in message PM100_Firmware_Info.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_firmware_info_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pm100_project_code_eep_ver;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pm100_sw_version;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pm100_date_code_mmdd;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pm100_date_code_yyyy;
};

/**
 * Signals in message PM100_Diag_Data.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_diag_data_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_buffer_record;

    /**
     * Range: 0..5 (0..5 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_buffer_segment;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pm100_diag_data_1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pm100_diag_data_2;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pm100_diag_data_3;
};

/**
 * Signals in message PM100_U2C_Command_Txd.
 *
 * Enable message sent to Delphi DC/DC converter.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_u2_c_command_txd_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_id_byte;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_setpoint_calc;
};

/**
 * Signals in message PM100_U2C_Message_Rxd.
 *
 * Response from Delphi DC/DC converter.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_u2_c_message_rxd_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_hv_input_current_validity;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_14_v_master_fault;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_hv_input_current;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_dtc_status;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_dtc_index;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_14_v_monitor;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_14_v_conditional;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pm100_14_v_current_monitor;
};

/**
 * Signals in message BMS_Current_Limit.
 *
 * Message sent by BMS for inverter DC current limiting.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_bms_current_limit_t {
    /**
     * Maximum discharge current from BMS
     *
     * Range: 0..1000 (0..1000 A)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pm100_max_discharge_current;

    /**
     * Maximum charge current from BMS
     *
     * Range: 0..1000 (0..1000 A)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pm100_max_charge_current;
};

/**
 * Signals in message PM100_Fast_Info.
 *
 * To enable fast message set CAN ACTIVE MSGS HI WORD to 0xFFFE.  Setting to default value of 0xFFFF will disable the fast message.
 *
 * All signal values are as on the CAN bus.
 */
struct can_c_pm100_fast_info_t {
    /**
     * The commanded torque
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_fast_torque_command;

    /**
     * The estimated torque
     *
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_fast_torque_feedback;

    /**
     * Motor speed
     *
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t pm100_fast_motor_speed;

    /**
     * DC Bus Voltage
     *
     * Range: -32768..32767 (-3276.8..3276.7 V)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t pm100_fast_dc_bus_voltage;
};

/**
 * Pack message VCU_Error.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_vcu_error_pack(
    uint8_t *dst_p,
    const struct can_c_vcu_error_t *src_p,
    size_t size);

/**
 * Unpack message VCU_Error.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_vcu_error_unpack(
    struct can_c_vcu_error_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_Error.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_vcu_error_init(struct can_c_vcu_error_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_vcu_error_vcu_ctrl_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_error_vcu_ctrl_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_error_vcu_ctrl_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_vcu_error_vcu_scs_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_error_vcu_scs_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_error_vcu_scs_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_vcu_error_vcu_pm100_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_error_vcu_pm100_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_error_vcu_pm100_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_vcu_error_vcu_rtcan1_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_error_vcu_rtcan1_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_error_vcu_rtcan1_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_vcu_error_vcu_rtcan2_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_error_vcu_rtcan2_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_error_vcu_rtcan2_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_vcu_error_vcu_canbc_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_error_vcu_canbc_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_error_vcu_canbc_error_is_in_range(uint8_t value);

/**
 * Pack message VCU_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_vcu_state_pack(
    uint8_t *dst_p,
    const struct can_c_vcu_state_t *src_p,
    size_t size);

/**
 * Unpack message VCU_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_vcu_state_unpack(
    struct can_c_vcu_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_State.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_vcu_state_init(struct can_c_vcu_state_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_vcu_state_vcu_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_state_vcu_rolling_counter_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_state_vcu_rolling_counter_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_vcu_state_vcu_ctrl_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_state_vcu_ctrl_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_state_vcu_ctrl_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_vcu_state_vcu_r2_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_state_vcu_r2_d_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_state_vcu_r2_d_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_vcu_state_vcu_drs_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_state_vcu_drs_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_state_vcu_drs_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_vcu_state_vcu_drs_allowed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_state_vcu_drs_allowed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_state_vcu_drs_allowed_is_in_range(uint8_t value);

/**
 * Pack message VCU_Sensors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_vcu_sensors_pack(
    uint8_t *dst_p,
    const struct can_c_vcu_sensors_t *src_p,
    size_t size);

/**
 * Unpack message VCU_Sensors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_vcu_sensors_unpack(
    struct can_c_vcu_sensors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from VCU_Sensors.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_vcu_sensors_init(struct can_c_vcu_sensors_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_vcu_sensors_vcu_apps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_sensors_vcu_apps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_sensors_vcu_apps_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_vcu_sensors_vcu_bps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_sensors_vcu_bps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_sensors_vcu_bps_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_vcu_sensors_vcu_sagl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_sensors_vcu_sagl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_sensors_vcu_sagl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_vcu_sensors_vcu_torque_request_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_vcu_sensors_vcu_torque_request_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_vcu_sensors_vcu_torque_request_is_in_range(uint16_t value);

/**
 * Pack message PM100_Modulation_And_Flux_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_modulation_and_flux_info_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_modulation_and_flux_info_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Modulation_And_Flux_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_modulation_and_flux_info_unpack(
    struct can_c_pm100_modulation_and_flux_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Modulation_And_Flux_Info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_modulation_and_flux_info_init(struct can_c_pm100_modulation_and_flux_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_modulation_and_flux_info_pm100_modulation_index_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_modulation_and_flux_info_pm100_modulation_index_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_modulation_and_flux_info_pm100_modulation_index_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_modulation_and_flux_info_pm100_flux_weakening_output_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_modulation_and_flux_info_pm100_flux_weakening_output_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_modulation_and_flux_info_pm100_flux_weakening_output_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_modulation_and_flux_info_pm100_id_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_modulation_and_flux_info_pm100_id_command_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_modulation_and_flux_info_pm100_id_command_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_modulation_and_flux_info_pm100_iq_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_modulation_and_flux_info_pm100_iq_command_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_modulation_and_flux_info_pm100_iq_command_is_in_range(int16_t value);

/**
 * Pack message PM100_Torque_And_Timer_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_torque_and_timer_info_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_torque_and_timer_info_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Torque_And_Timer_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_torque_and_timer_info_unpack(
    struct can_c_pm100_torque_and_timer_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Torque_And_Timer_Info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_torque_and_timer_info_init(struct can_c_pm100_torque_and_timer_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_torque_and_timer_info_pm100_commanded_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_torque_and_timer_info_pm100_commanded_torque_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_torque_and_timer_info_pm100_commanded_torque_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_torque_and_timer_info_pm100_torque_feedback_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_torque_and_timer_info_pm100_torque_feedback_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_torque_and_timer_info_pm100_torque_feedback_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can_c_pm100_torque_and_timer_info_pm100_power_on_timer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_torque_and_timer_info_pm100_power_on_timer_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_torque_and_timer_info_pm100_power_on_timer_is_in_range(uint32_t value);

/**
 * Pack message PM100_Read_Write_Param_Response.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_read_write_param_response_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_read_write_param_response_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Read_Write_Param_Response.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_read_write_param_response_unpack(
    struct can_c_pm100_read_write_param_response_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Read_Write_Param_Response.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_read_write_param_response_init(struct can_c_pm100_read_write_param_response_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_read_write_param_response_pm100_parameter_address_response_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_read_write_param_response_pm100_parameter_address_response_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_read_write_param_response_pm100_parameter_address_response_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_read_write_param_response_pm100_write_success_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_read_write_param_response_pm100_write_success_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_read_write_param_response_pm100_write_success_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_read_write_param_response_pm100_data_response_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_read_write_param_response_pm100_data_response_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_read_write_param_response_pm100_data_response_is_in_range(int16_t value);

/**
 * Pack message PM100_Read_Write_Param_Command.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_read_write_param_command_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_read_write_param_command_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Read_Write_Param_Command.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_read_write_param_command_unpack(
    struct can_c_pm100_read_write_param_command_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Read_Write_Param_Command.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_read_write_param_command_init(struct can_c_pm100_read_write_param_command_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_read_write_param_command_pm100_parameter_address_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_read_write_param_command_pm100_parameter_address_command_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_read_write_param_command_pm100_parameter_address_command_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_read_write_param_command_pm100_read_write_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_read_write_param_command_pm100_read_write_command_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_read_write_param_command_pm100_read_write_command_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_read_write_param_command_pm100_data_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_read_write_param_command_pm100_data_command_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_read_write_param_command_pm100_data_command_is_in_range(int16_t value);

/**
 * Pack message PM100_Command_Message.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_command_message_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_command_message_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Command_Message.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_command_message_unpack(
    struct can_c_pm100_command_message_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Command_Message.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_command_message_init(struct can_c_pm100_command_message_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_command_message_pm100_torque_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_command_message_pm100_torque_command_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_command_message_pm100_torque_command_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_command_message_pm100_speed_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_command_message_pm100_speed_command_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_command_message_pm100_speed_command_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_command_message_pm100_direction_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_command_message_pm100_direction_command_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_command_message_pm100_direction_command_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_command_message_pm100_inverter_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_command_message_pm100_inverter_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_command_message_pm100_inverter_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_command_message_pm100_inverter_discharge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_command_message_pm100_inverter_discharge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_command_message_pm100_inverter_discharge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_command_message_pm100_speed_mode_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_command_message_pm100_speed_mode_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_command_message_pm100_speed_mode_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_command_message_pm100_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_command_message_pm100_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_command_message_pm100_rolling_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_command_message_pm100_torque_limit_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_command_message_pm100_torque_limit_command_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_command_message_pm100_torque_limit_command_is_in_range(int16_t value);

/**
 * Pack message PM100_Fault_Codes.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_fault_codes_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_fault_codes_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Fault_Codes.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_fault_codes_unpack(
    struct can_c_pm100_fault_codes_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Fault_Codes.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_fault_codes_init(struct can_c_pm100_fault_codes_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_fault_codes_pm100_post_fault_lo_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_fault_codes_pm100_post_fault_lo_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_fault_codes_pm100_post_fault_lo_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_fault_codes_pm100_post_fault_hi_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_fault_codes_pm100_post_fault_hi_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_fault_codes_pm100_post_fault_hi_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_fault_codes_pm100_run_fault_lo_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_fault_codes_pm100_run_fault_lo_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_fault_codes_pm100_run_fault_lo_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_fault_codes_pm100_run_fault_hi_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_fault_codes_pm100_run_fault_hi_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_fault_codes_pm100_run_fault_hi_is_in_range(uint16_t value);

/**
 * Pack message PM100_Internal_States.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_internal_states_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_internal_states_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Internal_States.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_internal_states_unpack(
    struct can_c_pm100_internal_states_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Internal_States.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_internal_states_init(struct can_c_pm100_internal_states_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_vsm_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_vsm_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_vsm_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_pwm_frequency_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_pwm_frequency_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_pwm_frequency_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_inverter_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_inverter_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_inverter_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_relay_1_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_relay_1_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_relay_1_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_relay_2_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_relay_2_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_relay_2_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_relay_3_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_relay_3_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_relay_3_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_relay_4_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_relay_4_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_relay_4_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_relay_5_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_relay_5_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_relay_5_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_relay_6_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_relay_6_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_relay_6_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_inverter_run_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_inverter_run_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_inverter_run_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_inverter_discharge_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_inverter_discharge_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_inverter_discharge_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_inverter_command_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_inverter_command_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_inverter_command_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_rolling_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_rolling_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_rolling_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_inverter_enable_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_inverter_enable_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_inverter_enable_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_start_mode_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_start_mode_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_start_mode_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_inverter_enable_lockout_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_inverter_enable_lockout_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_inverter_enable_lockout_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_direction_command_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_direction_command_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_direction_command_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_bms_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_bms_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_bms_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_bms_torque_limiting_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_bms_torque_limiting_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_bms_torque_limiting_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_max_speed_limiting_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_max_speed_limiting_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_max_speed_limiting_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_internal_states_pm100_low_speed_limiting_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_states_pm100_low_speed_limiting_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_states_pm100_low_speed_limiting_is_in_range(uint8_t value);

/**
 * Pack message PM100_Internal_Voltages.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_internal_voltages_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_internal_voltages_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Internal_Voltages.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_internal_voltages_unpack(
    struct can_c_pm100_internal_voltages_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Internal_Voltages.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_internal_voltages_init(struct can_c_pm100_internal_voltages_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_internal_voltages_pm100_reference_voltage_1_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_voltages_pm100_reference_voltage_1_5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_voltages_pm100_reference_voltage_1_5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_internal_voltages_pm100_reference_voltage_2_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_voltages_pm100_reference_voltage_2_5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_voltages_pm100_reference_voltage_2_5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_internal_voltages_pm100_reference_voltage_5_0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_voltages_pm100_reference_voltage_5_0_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_voltages_pm100_reference_voltage_5_0_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_internal_voltages_pm100_reference_voltage_12_0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_internal_voltages_pm100_reference_voltage_12_0_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_internal_voltages_pm100_reference_voltage_12_0_is_in_range(int16_t value);

/**
 * Pack message PM100_Flux_ID_IQ_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_flux_id_iq_info_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_flux_id_iq_info_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Flux_ID_IQ_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_flux_id_iq_info_unpack(
    struct can_c_pm100_flux_id_iq_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Flux_ID_IQ_Info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_flux_id_iq_info_init(struct can_c_pm100_flux_id_iq_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_flux_id_iq_info_pm100_flux_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_flux_id_iq_info_pm100_flux_command_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_flux_id_iq_info_pm100_flux_command_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_flux_id_iq_info_pm100_flux_feedback_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_flux_id_iq_info_pm100_flux_feedback_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_flux_id_iq_info_pm100_flux_feedback_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_flux_id_iq_info_pm100_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_flux_id_iq_info_pm100_id_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_flux_id_iq_info_pm100_id_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_flux_id_iq_info_pm100_iq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_flux_id_iq_info_pm100_iq_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_flux_id_iq_info_pm100_iq_is_in_range(int16_t value);

/**
 * Pack message PM100_Voltage_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_voltage_info_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_voltage_info_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Voltage_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_voltage_info_unpack(
    struct can_c_pm100_voltage_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Voltage_Info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_voltage_info_init(struct can_c_pm100_voltage_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_voltage_info_pm100_dc_bus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_voltage_info_pm100_dc_bus_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_voltage_info_pm100_dc_bus_voltage_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_voltage_info_pm100_output_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_voltage_info_pm100_output_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_voltage_info_pm100_output_voltage_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_voltage_info_pm100_vab_vd_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_voltage_info_pm100_vab_vd_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_voltage_info_pm100_vab_vd_voltage_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_voltage_info_pm100_vbc_vq_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_voltage_info_pm100_vbc_vq_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_voltage_info_pm100_vbc_vq_voltage_is_in_range(int16_t value);

/**
 * Pack message PM100_Current_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_current_info_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_current_info_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Current_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_current_info_unpack(
    struct can_c_pm100_current_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Current_Info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_current_info_init(struct can_c_pm100_current_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_current_info_pm100_phase_a_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_current_info_pm100_phase_a_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_current_info_pm100_phase_a_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_current_info_pm100_phase_b_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_current_info_pm100_phase_b_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_current_info_pm100_phase_b_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_current_info_pm100_phase_c_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_current_info_pm100_phase_c_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_current_info_pm100_phase_c_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_current_info_pm100_dc_bus_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_current_info_pm100_dc_bus_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_current_info_pm100_dc_bus_current_is_in_range(int16_t value);

/**
 * Pack message PM100_Motor_Position_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_motor_position_info_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_motor_position_info_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Motor_Position_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_motor_position_info_unpack(
    struct can_c_pm100_motor_position_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Motor_Position_Info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_motor_position_info_init(struct can_c_pm100_motor_position_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_motor_position_info_pm100_motor_angle_electrical_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_motor_position_info_pm100_motor_angle_electrical_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_motor_position_info_pm100_motor_angle_electrical_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_motor_position_info_pm100_motor_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_motor_position_info_pm100_motor_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_motor_position_info_pm100_motor_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_motor_position_info_pm100_electrical_output_freq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_motor_position_info_pm100_electrical_output_freq_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_motor_position_info_pm100_electrical_output_freq_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_motor_position_info_pm100_delta_resolver_filtered_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_motor_position_info_pm100_delta_resolver_filtered_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_motor_position_info_pm100_delta_resolver_filtered_is_in_range(int16_t value);

/**
 * Pack message PM100_Digital_Input_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_digital_input_status_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_digital_input_status_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Digital_Input_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_digital_input_status_unpack(
    struct can_c_pm100_digital_input_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Digital_Input_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_digital_input_status_init(struct can_c_pm100_digital_input_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_digital_input_status_pm100_digital_input_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_digital_input_status_pm100_digital_input_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_digital_input_status_pm100_digital_input_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_digital_input_status_pm100_digital_input_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_digital_input_status_pm100_digital_input_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_digital_input_status_pm100_digital_input_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_digital_input_status_pm100_digital_input_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_digital_input_status_pm100_digital_input_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_digital_input_status_pm100_digital_input_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_digital_input_status_pm100_digital_input_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_digital_input_status_pm100_digital_input_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_digital_input_status_pm100_digital_input_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_digital_input_status_pm100_digital_input_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_digital_input_status_pm100_digital_input_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_digital_input_status_pm100_digital_input_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_digital_input_status_pm100_digital_input_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_digital_input_status_pm100_digital_input_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_digital_input_status_pm100_digital_input_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_digital_input_status_pm100_digital_input_7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_digital_input_status_pm100_digital_input_7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_digital_input_status_pm100_digital_input_7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_digital_input_status_pm100_digital_input_8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_digital_input_status_pm100_digital_input_8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_digital_input_status_pm100_digital_input_8_is_in_range(uint8_t value);

/**
 * Pack message PM100_Analog_Input_Voltages.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_analog_input_voltages_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_analog_input_voltages_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Analog_Input_Voltages.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_analog_input_voltages_unpack(
    struct can_c_pm100_analog_input_voltages_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Analog_Input_Voltages.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_analog_input_voltages_init(struct can_c_pm100_analog_input_voltages_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_analog_input_voltages_pm100_analog_input_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_analog_input_voltages_pm100_analog_input_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_analog_input_voltages_pm100_analog_input_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_analog_input_voltages_pm100_analog_input_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_analog_input_voltages_pm100_analog_input_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_analog_input_voltages_pm100_analog_input_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_analog_input_voltages_pm100_analog_input_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_analog_input_voltages_pm100_analog_input_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_analog_input_voltages_pm100_analog_input_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_analog_input_voltages_pm100_analog_input_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_analog_input_voltages_pm100_analog_input_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_analog_input_voltages_pm100_analog_input_4_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_analog_input_voltages_pm100_analog_input_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_analog_input_voltages_pm100_analog_input_5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_analog_input_voltages_pm100_analog_input_5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_analog_input_voltages_pm100_analog_input_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_analog_input_voltages_pm100_analog_input_6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_analog_input_voltages_pm100_analog_input_6_is_in_range(uint16_t value);

/**
 * Pack message PM100_Temperature_Set_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_temperature_set_3_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_temperature_set_3_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Temperature_Set_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_temperature_set_3_unpack(
    struct can_c_pm100_temperature_set_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Temperature_Set_3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_temperature_set_3_init(struct can_c_pm100_temperature_set_3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_temperature_set_3_pm100_rtd4_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_temperature_set_3_pm100_rtd4_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_temperature_set_3_pm100_rtd4_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_temperature_set_3_pm100_rtd5_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_temperature_set_3_pm100_rtd5_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_temperature_set_3_pm100_rtd5_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_temperature_set_3_pm100_motor_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_temperature_set_3_pm100_motor_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_temperature_set_3_pm100_motor_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_temperature_set_3_pm100_torque_shudder_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_temperature_set_3_pm100_torque_shudder_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_temperature_set_3_pm100_torque_shudder_is_in_range(int16_t value);

/**
 * Pack message PM100_Temperature_Set_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_temperature_set_2_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_temperature_set_2_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Temperature_Set_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_temperature_set_2_unpack(
    struct can_c_pm100_temperature_set_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Temperature_Set_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_temperature_set_2_init(struct can_c_pm100_temperature_set_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_temperature_set_2_pm100_control_board_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_temperature_set_2_pm100_control_board_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_temperature_set_2_pm100_control_board_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_temperature_set_2_pm100_rtd1_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_temperature_set_2_pm100_rtd1_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_temperature_set_2_pm100_rtd1_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_temperature_set_2_pm100_rtd2_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_temperature_set_2_pm100_rtd2_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_temperature_set_2_pm100_rtd2_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_temperature_set_2_pm100_rtd3_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_temperature_set_2_pm100_rtd3_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_temperature_set_2_pm100_rtd3_temperature_is_in_range(int16_t value);

/**
 * Pack message PM100_Temperature_Set_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_temperature_set_1_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_temperature_set_1_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Temperature_Set_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_temperature_set_1_unpack(
    struct can_c_pm100_temperature_set_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Temperature_Set_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_temperature_set_1_init(struct can_c_pm100_temperature_set_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_temperature_set_1_pm100_module_a_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_temperature_set_1_pm100_module_a_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_temperature_set_1_pm100_module_a_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_temperature_set_1_pm100_module_b_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_temperature_set_1_pm100_module_b_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_temperature_set_1_pm100_module_b_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_temperature_set_1_pm100_module_c_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_temperature_set_1_pm100_module_c_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_temperature_set_1_pm100_module_c_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_temperature_set_1_pm100_gate_driver_board_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_temperature_set_1_pm100_gate_driver_board_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_temperature_set_1_pm100_gate_driver_board_is_in_range(int16_t value);

/**
 * Pack message PM100_Firmware_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_firmware_info_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_firmware_info_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Firmware_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_firmware_info_unpack(
    struct can_c_pm100_firmware_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Firmware_Info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_firmware_info_init(struct can_c_pm100_firmware_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_firmware_info_pm100_project_code_eep_ver_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_firmware_info_pm100_project_code_eep_ver_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_firmware_info_pm100_project_code_eep_ver_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_firmware_info_pm100_sw_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_firmware_info_pm100_sw_version_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_firmware_info_pm100_sw_version_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_firmware_info_pm100_date_code_mmdd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_firmware_info_pm100_date_code_mmdd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_firmware_info_pm100_date_code_mmdd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_pm100_firmware_info_pm100_date_code_yyyy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_firmware_info_pm100_date_code_yyyy_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_firmware_info_pm100_date_code_yyyy_is_in_range(uint16_t value);

/**
 * Pack message PM100_Diag_Data.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_diag_data_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_diag_data_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Diag_Data.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_diag_data_unpack(
    struct can_c_pm100_diag_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Diag_Data.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_diag_data_init(struct can_c_pm100_diag_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_diag_data_pm100_buffer_record_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_diag_data_pm100_buffer_record_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_diag_data_pm100_buffer_record_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_diag_data_pm100_buffer_segment_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_diag_data_pm100_buffer_segment_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_diag_data_pm100_buffer_segment_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_diag_data_pm100_diag_data_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_diag_data_pm100_diag_data_1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_diag_data_pm100_diag_data_1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_diag_data_pm100_diag_data_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_diag_data_pm100_diag_data_2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_diag_data_pm100_diag_data_2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_diag_data_pm100_diag_data_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_diag_data_pm100_diag_data_3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_diag_data_pm100_diag_data_3_is_in_range(int16_t value);

/**
 * Pack message PM100_U2C_Command_Txd.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_u2_c_command_txd_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_u2_c_command_txd_t *src_p,
    size_t size);

/**
 * Unpack message PM100_U2C_Command_Txd.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_u2_c_command_txd_unpack(
    struct can_c_pm100_u2_c_command_txd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_U2C_Command_Txd.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_u2_c_command_txd_init(struct can_c_pm100_u2_c_command_txd_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_u2_c_command_txd_pm100_id_byte_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_u2_c_command_txd_pm100_id_byte_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_u2_c_command_txd_pm100_id_byte_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_u2_c_command_txd_pm100_setpoint_calc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_u2_c_command_txd_pm100_setpoint_calc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_u2_c_command_txd_pm100_setpoint_calc_is_in_range(uint8_t value);

/**
 * Pack message PM100_U2C_Message_Rxd.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_u2_c_message_rxd_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_u2_c_message_rxd_t *src_p,
    size_t size);

/**
 * Unpack message PM100_U2C_Message_Rxd.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_u2_c_message_rxd_unpack(
    struct can_c_pm100_u2_c_message_rxd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_U2C_Message_Rxd.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_u2_c_message_rxd_init(struct can_c_pm100_u2_c_message_rxd_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_u2_c_message_rxd_pm100_hv_input_current_validity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_u2_c_message_rxd_pm100_hv_input_current_validity_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_u2_c_message_rxd_pm100_hv_input_current_validity_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_u2_c_message_rxd_pm100_14_v_master_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_u2_c_message_rxd_pm100_14_v_master_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_u2_c_message_rxd_pm100_14_v_master_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_u2_c_message_rxd_pm100_hv_input_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_u2_c_message_rxd_pm100_hv_input_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_u2_c_message_rxd_pm100_hv_input_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_u2_c_message_rxd_pm100_dtc_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_u2_c_message_rxd_pm100_dtc_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_u2_c_message_rxd_pm100_dtc_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_u2_c_message_rxd_pm100_dtc_index_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_u2_c_message_rxd_pm100_dtc_index_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_u2_c_message_rxd_pm100_dtc_index_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_u2_c_message_rxd_pm100_14_v_monitor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_u2_c_message_rxd_pm100_14_v_monitor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_u2_c_message_rxd_pm100_14_v_monitor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_u2_c_message_rxd_pm100_14_v_conditional_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_u2_c_message_rxd_pm100_14_v_conditional_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_u2_c_message_rxd_pm100_14_v_conditional_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can_c_pm100_u2_c_message_rxd_pm100_14_v_current_monitor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_u2_c_message_rxd_pm100_14_v_current_monitor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_u2_c_message_rxd_pm100_14_v_current_monitor_is_in_range(uint8_t value);

/**
 * Pack message BMS_Current_Limit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_bms_current_limit_pack(
    uint8_t *dst_p,
    const struct can_c_bms_current_limit_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Current_Limit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_bms_current_limit_unpack(
    struct can_c_bms_current_limit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_Current_Limit.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_bms_current_limit_init(struct can_c_bms_current_limit_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_bms_current_limit_pm100_max_discharge_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_bms_current_limit_pm100_max_discharge_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_bms_current_limit_pm100_max_discharge_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can_c_bms_current_limit_pm100_max_charge_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_bms_current_limit_pm100_max_charge_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_bms_current_limit_pm100_max_charge_current_is_in_range(uint16_t value);

/**
 * Pack message PM100_Fast_Info.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can_c_pm100_fast_info_pack(
    uint8_t *dst_p,
    const struct can_c_pm100_fast_info_t *src_p,
    size_t size);

/**
 * Unpack message PM100_Fast_Info.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can_c_pm100_fast_info_unpack(
    struct can_c_pm100_fast_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PM100_Fast_Info.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int can_c_pm100_fast_info_init(struct can_c_pm100_fast_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_fast_info_pm100_fast_torque_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_fast_info_pm100_fast_torque_command_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_fast_info_pm100_fast_torque_command_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_fast_info_pm100_fast_torque_feedback_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_fast_info_pm100_fast_torque_feedback_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_fast_info_pm100_fast_torque_feedback_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_fast_info_pm100_fast_motor_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_fast_info_pm100_fast_motor_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_fast_info_pm100_fast_motor_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can_c_pm100_fast_info_pm100_fast_dc_bus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can_c_pm100_fast_info_pm100_fast_dc_bus_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can_c_pm100_fast_info_pm100_fast_dc_bus_voltage_is_in_range(int16_t value);


#ifdef __cplusplus
}
#endif

#endif
